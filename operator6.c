#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

//下标引用操作符
//操作数：一个数组名+一个索引值

int main()
{
	int a[10] = { 0 };  //创建数组初始化
	a[4] = 10;  //实用下标引用操作符
	//[ ]的两个操作数是a和4
	
	return 0;
}

//2.()函数调用操作符：接收一个或者多个操作数：第一个操作时函数名,剩余的操作数就是传递给函数的参数
int get_max(int x, int y)
{
	return x > y ? x : y;
}
int main()
{
	int a = 10;
	int b = 20;
	int max = get_max(a, b);    //调用函数的时候的()就是函数调用操作符,get_max , a , b都为操作数
	printf("max = %d\n", max);
	return 0;
}


//学生
//创建一个结构体类型 - struct Stu
struct Stu  //struct Stu就相当于数据类型,地位相当于int, double,float等
{
	//成员变量
	char name[20];
	int age;
	char id[20];
};

int main()
{
	//使用struct Stu这个类型创建了一个学生对象s1,并进行初始化
	struct Stu s1 = { "张三",18,"2018012609" };

	printf("%s\n", s1.name);
	printf("%d\n", s1.age);
	printf("%s\n", s1.id);
	//结构体变量.成员名

	struct Stu * ps = &s1;  //*表示ps做指针使用,struct Stu表示指针指向元素的类型
	/*printf("%s\n", (*ps).name);*/
	printf("%s\n", ps->name);
	return 0;
}



//表达式求值
//表达式求值的顺序一部分是由操作符的优先级和结合性决定.同样,有些表达式的操作数在求值的过程中可能需要转换为其他类型


//隐式类型转换
//C的整形算术运算总是至少以缺省整型类型的精度来进行的
//为了获得这个精度,表达式中的字符和短整型操作数在使用之前被转换为普通整型,这种转换称为整型提升.
int main()
{
	char a = 3;
	//00000000000000000000000000000011  - char类型的内存只有一个字节,发生截断,只存放最低位的8个比特位
	//00000011 - a
	char b = 127;
	//同理01111111 - b
	char c = a + b;
	//a和b相加时发生整型提升 - 整型提升时按照变量的数据类型的符号位来提升的
	//所以a和b的第一位会被当成符号位
	//00000000000000000000000000000011 - a
	//00000000000000000000000001111111 - b
	//00000000000000000000000010000010 - 相加的结果
	//将结果放入c中时又发生截断,所以只有后8比特位放入c - 10000010
	//打印的时候c的格式化类型为%d,又要发生整型提升
	//按照变量的数据类型的符号位来提升的
	//11111111111111111111111110000010 - 补码
	//11111111111111111111111110000001 - 反码
	//10000000000000000000000001111110 - 原码  -  -126
	printf("%d\n", c);  //结果为-126
	return 0;
}

//实例1：
int main()
{
	char a = 0xb6;
	short b = 0xb600;
	int c = 0xb6000000;
	if (a == 0xb6)
		printf("a");
	if (b == 0xb600)
		printf("b");
	if (c == 0xb6000000)
		printf("c");
	//最终打印结果只有c
	return 0;
}

//实例2：
int main()
{
	char c = 1;
	printf("%u\n", sizeof(c));  //1
	printf("%u\n", sizeof(+c)); //4  +c进行了运算,发生了整型提升
	printf("%u\n", sizeof(!c)); //1
	return 0;
}


//算术转换
//如果某个操作符的各个操作数属于不同的类型,那么除非其中一个操作数的转换为另一个操作数的类型,否则操作就无法进行.下面的层次体系称为寻常算术转换

//long double
//double
//float
//unsigned long int
//long int
//unsigned int
//int
//如果某个操作数的类型在上面这个列表中的排名较低,那么首先要转换为另一个操作数的类型后执行运算


//操作符的属性  复杂表达式的求值有三个影响的因素
//1.操作符的优先级  2.操作符的结合性  3.是否控制求值顺序
int main()
{
	int a = 10;
	int b = 20;
	int c = b + a * 3;  //优先级
	int d = b + a + 3;  //结合性
	//例如&&,||等从左到右计算可能随时中断 ,为是否控制求值顺序
	return 0;
}

//问题表达式： a*b + c*d + e*f
//在计算的时候,由于比+的优先级高,只能保证的计算是比+早,但是优先级并不能决定第三个*比第一个+早执行,所以没有唯一的计算路径

//c + --c
//操作符的优先级只能决定自减--的运算在+的前面,但并不知道+操作符的左操作数的获取是在右操作数之前还是之后求值,所以结果不可预测

//非法表达式
int main()
{
	int i = 0;
	i = i-- - --i*(i = -3)*i++ + ++i;
	printf("i = %d\n", i);
	return 0;
}

//问题代码
int fun()
{
	static int count = 1;
	return ++count;
}
int main()
{
	int answer;
	answer = fun() - fun() * fun();  //无法确定fun()函数哪个先调用
	printf("%d\n", answer);//输出多少？
	return 0;
}